{
  "hash": "f5b8f880ee667015430f7741e34a2ee9",
  "result": {
    "engine": "knitr",
    "markdown": "---\nlesson: PrePro1\nexecute: \n  echo: false   # set to true to show musterlösung\n  output: false # set to true to show musterlösung\ncode-fold: true\ncode-summary: \"Musterlösung\"\nknitr:\n  opts_chunk: \n    collapse: true\n---\n\n\n\n\n\n# PrePro 1: Übung\n\n\n\n\n\n\n\n\n\n\n\n## Arbeiten mit RStudio \"Project\"\n\nWir empfehlen die Verwendung von \"Projects\" innerhalb von RStudio. RStudio legt für jedes Projekt dann einen Ordner an, in welches die Projekt-Datei abgelegt wird (Dateiendung `.Rproj`). Sollen innerhalb des Projekts dann R-Skripts geladen oder erzeugt werden, werden diese dann auch im angelegten Ordner abgelegt. Mehr zu RStudio Projects findet ihr [hier](https://support.rstudio.com/hc/en-us/articles/200526207-Using-Projects).\n\n\n\nDas Verwenden von Projects bringt verschiedene Vorteile, wie zum Beispiel:\n\n-   Festlegen der Working Directory ohne die Verwendung des expliziten Pfades (`setwd()`). Das ist sinnvoll, da sich dieser Pfad ändern kann (Zusammenarbeit mit anderen Usern, Ausführung des Scripts zu einem späteren Zeitpunkt)\n-   Automatisches Zwischenspeichern geöffneter Scripts und Wiederherstellung der geöffneten Scripts bei der nächsten Session\n-   Festlegen verschiedener projektspezifischer Optionen\n-   Verwendung von Versionsverwaltungssystemen (z.B. *git*)\n\n\n\n:::{.callout-important}\n\n## Prüfungsrelevant\n\nDie korrekte Verwendung von RStudio Projects und relativen Pfaden wird an der praktischen Prüfung vorausgesetzt!\n\n:::\n\n\n## Aufgabe 1\n\nErstelle eine `data.frame` mit nachstehenden Daten.\n\n\n\n\n\n::: {.cell}\n\n:::\n\n::: {.cell}\n::: {.cell-output-display}\n\n\n|Tierart | Anzahl| Gewicht|Geschlecht |Beschreibung                |\n|:-------|------:|-------:|:----------|:---------------------------|\n|Fuchs   |      2|     4.4|m          |Rötlich                     |\n|Bär     |      5|    40.3|f          |Braun, gross                |\n|Hase    |      1|     1.1|m          |klein, mit langen Ohren     |\n|Elch    |      3|   120.0|m          |Lange Beine, Schaufelgeweih |\n\n\n:::\n:::\n\n\n\n\n\n## Aufgabe 2\n\nWas für Daten*typen* wurden in der letzten Aufgabe automatisch angenommen? Ermittle diese mit `str()` und prüfe, ob diese sinnvoll sind und wandle um wo nötig.\n\n\n\n\n\n::: {.cell}\n\n:::\n\n\n\n\n\n## Aufgabe 3\n\nNutze die Spalte `Gewicht` um die Tiere in 3 Gewichtskategorien einzuteilen:\n\n-   leicht: \\< 5kg\n-   mittel: 5 - 100 kg\n-   schwer: \\> 100kg\n\n\n\n\n\n::: {.cell}\n\n:::\n\n\n\n\n\nDas Resultat:\n\n\n\n\n\n::: {.cell}\n::: {.cell-output-display}\n\n\n|Tierart | Anzahl| Gewicht|Geschlecht |Beschreibung                |Gewichtsklasse |\n|:-------|------:|-------:|:----------|:---------------------------|:--------------|\n|Fuchs   |      2|     4.4|m          |Rötlich                     |leicht         |\n|Bär     |      5|    40.3|f          |Braun, gross                |mittel         |\n|Hase    |      1|     1.1|m          |klein, mit langen Ohren     |leicht         |\n|Elch    |      3|   120.0|m          |Lange Beine, Schaufelgeweih |schwer         |\n\n\n:::\n:::\n\n\n\n\n\n## Aufgabe 4\n\nAuf Moodle findest du ein Zip-Files mit dem Namen *prepro.zip*. Lade das File herunter und entpacke es **in deinem Projektordner**. Importiere die Datei `weather.csv`. Falls du dafür das RStudio GUI verwendest, speichere den Import-Befehl in deinem R-Script ab. Bitte verwende einen relativen Pfad (also kein Pfad der mit `C:/`, `~/` o.ä. beginnt).)\n\n:::{.callout-note}\nWir nutzen `readr` um csvs zu importieren und verwenden die Funktion `read_delim` (mit *underscore*) als alternative zu `read.csv` oder `read.delim` (mit *Punkt*). Das ist eine persönliche Präferenz[^readr], es ist euch überlassen welche Funktion ihr verwendet. Beachtet, dass die beiden Funktionen leicht andere Parameter erwarten.\n:::\n\n[^readr]: Vorteile von `read_delim` gegenüber `read.csv`: <https://stackoverflow.com/a/60374974/4139249>\n\n\n\n\n\n\n\n\n::: {.cell}\n\n:::\n\n::: {.cell}\n::: {.cell-output-display}\n\n\n|stn |       time| tre200h0|\n|:---|----------:|--------:|\n|ABO | 2000010100|     -2.6|\n|ABO | 2000010101|     -2.5|\n|ABO | 2000010102|     -3.1|\n|ABO | 2000010103|     -2.4|\n|ABO | 2000010104|     -2.5|\n|ABO | 2000010105|     -3.0|\n|ABO | 2000010106|     -3.7|\n|ABO | 2000010107|     -4.4|\n|ABO | 2000010108|     -4.1|\n|ABO | 2000010109|     -4.1|\n\n\n:::\n:::\n\n\n\n\n\n## Aufgabe 5\n\nSchau dir die Rückmeldung von `read_delim()`an. Sind die Daten korrekt interpretiert worden?\n\n\n\n\n\n::: {.cell}\n\n:::\n\n\n\n\n\n## Aufgabe 6\n\nDie Spalte `time` ist eine Datum/Zeitangabe im Format JJJJMMTTHH (siehe *meta.txt*). Damit R dies als Datum-/Zeitangabe erkennt, müssen wir die Spalte in einem R-Format (`POSIXct`) einlesen und dabei R mitteilen, wie sie aktuell formatiert ist. Lies die Spalte mit `as.POSIXct()` ein und spezifiziere sowohl `format` wie auch `tz`.\n\n:::{.callout-tip}\n- Wenn keine Zeitzone festgelegt wird, trifft `as.POSIXct()` eine Annahme (basierend auf `Sys.timezone()`). In unserem Fall handelt es sich aber um Werte in UTC (siehe *metadata.csv*)\n- `as.POSIXct`erwartet `character`: Wenn du eine Fehlermeldung hast die `'origin' must be supplied` (o.ä) heisst, hast du der Funktion vermutlich einen `Numeric` übergeben.\n:::\n\n\n\n\n\n::: {.cell}\n\n:::\n\n::: {.cell}\n::: {.cell-output-display}\n\n\nTable: Die neue Tabelle sollte so aussehen\n\n|stn |time                | tre200h0|\n|:---|:-------------------|--------:|\n|ABO |2000-01-01 00:00:00 |     -2.6|\n|ABO |2000-01-01 01:00:00 |     -2.5|\n|ABO |2000-01-01 02:00:00 |     -3.1|\n|ABO |2000-01-01 03:00:00 |     -2.4|\n|ABO |2000-01-01 04:00:00 |     -2.5|\n|ABO |2000-01-01 05:00:00 |     -3.0|\n|ABO |2000-01-01 06:00:00 |     -3.7|\n|ABO |2000-01-01 07:00:00 |     -4.4|\n|ABO |2000-01-01 08:00:00 |     -4.1|\n|ABO |2000-01-01 09:00:00 |     -4.1|\n\n\n:::\n:::\n\n\n\n\n\n## Aufgabe 7\n\nErstelle zwei neue Spalten mit Wochentag (Montag, Dienstag, etc) und Kalenderwoche. Verwende dazu die neu erstellte `POSIXct`-Spalte sowie eine geeignete Funktion aus `lubridate`.\n\n\n\n\n\n::: {.cell}\n\n:::\n\n::: {.cell}\n::: {.cell-output-display}\n\n\n|stn |time                | tre200h0|wochentag | kw|\n|:---|:-------------------|--------:|:---------|--:|\n|ABO |2000-01-01 00:00:00 |     -2.6|Sat       |  1|\n|ABO |2000-01-01 01:00:00 |     -2.5|Sat       |  1|\n|ABO |2000-01-01 02:00:00 |     -3.1|Sat       |  1|\n|ABO |2000-01-01 03:00:00 |     -2.4|Sat       |  1|\n|ABO |2000-01-01 04:00:00 |     -2.5|Sat       |  1|\n|ABO |2000-01-01 05:00:00 |     -3.0|Sat       |  1|\n|ABO |2000-01-01 06:00:00 |     -3.7|Sat       |  1|\n|ABO |2000-01-01 07:00:00 |     -4.4|Sat       |  1|\n|ABO |2000-01-01 08:00:00 |     -4.1|Sat       |  1|\n|ABO |2000-01-01 09:00:00 |     -4.1|Sat       |  1|\n\n\n:::\n:::\n\n\n\n\n\n## Aufgabe 8\n\nErstelle eine neue Spalte basierend auf die Temperaturwerte mit der Einteilung \"kalt\" (unter Null Grad) und \"warm\" (über Null Grad)\n\n\n\n\n\n::: {.cell}\n\n:::\n\n::: {.cell}\n::: {.cell-output-display}\n\n\n|stn |time                | tre200h0|wochentag | kw|temp_kat |\n|:---|:-------------------|--------:|:---------|--:|:--------|\n|ABO |2000-01-01 00:00:00 |     -2.6|Sat       |  1|kalt     |\n|ABO |2000-01-01 01:00:00 |     -2.5|Sat       |  1|kalt     |\n|ABO |2000-01-01 02:00:00 |     -3.1|Sat       |  1|kalt     |\n|ABO |2000-01-01 03:00:00 |     -2.4|Sat       |  1|kalt     |\n|ABO |2000-01-01 04:00:00 |     -2.5|Sat       |  1|kalt     |\n|ABO |2000-01-01 05:00:00 |     -3.0|Sat       |  1|kalt     |\n|ABO |2000-01-01 06:00:00 |     -3.7|Sat       |  1|kalt     |\n|ABO |2000-01-01 07:00:00 |     -4.4|Sat       |  1|kalt     |\n|ABO |2000-01-01 08:00:00 |     -4.1|Sat       |  1|kalt     |\n|ABO |2000-01-01 09:00:00 |     -4.1|Sat       |  1|kalt     |\n\n\n:::\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}