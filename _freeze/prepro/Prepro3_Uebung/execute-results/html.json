{
  "hash": "cf4caa5a5a1f823f5605d8d4a863a830",
  "result": {
    "engine": "knitr",
    "markdown": "---\nlesson: PrePro3\nthema: Split-Apply-Combine\nexecute: \n  echo: false   # set to true to show musterlösung\n  output: false # set to true to show musterlösung\ncode-fold: true\ncode-summary: \"Musterlösung\"\nknitr:\n  opts_chunk: \n    collapse: true\n---\n\n\n# Prepro 3: Übung\n\n## Aufgabe 1\n\nGegeben sei ein Datensatz *sensors_combined.csv*, mit den Temperaturwerten von drei verschiedenen Sensoren. Importiere ihn als csv in R (als `sensors_combined`). \n\nFormatiere die `Datetime` Spalte in `POSIXct` um. Verwende dazu die Funktion `as.POSIXct` (lies mit `?strftime()` nochmal nach, wie du das spezfische Format (die \"Schablone\") festlegen kannst.\n\n\n::: {.cell}\n\n:::\n\n\n## Aufgabe 2\n\nÜberführe die Tabelle in ein *langes* Format (verwende dazu die Funktion `pivot_longer` aus `tidyr`) und speichere den output als `sensors_long`. \n\nTipp: \n\n- im Argument `cols` kannst du entweder die Spalten auflisten, die \"pivotiert\" werden sollen. \n- Alternativ kannst du (mit vorangestelltem Minuszeichen, `-`) die Spalte bezeichnen, die *nicht* pivotiert werden soll. \n- In beiden Fällen musst du die Spalten weder mit Anführungs- und Schlusszeichen noch mit dem `$`-Zeichen versehen.\n\n\n::: {.cell}\n\n:::\n\n\n## Aufgabe 3\n\nGruppiere `sensors_long` nach der neuen Spalte, wo die Sensor-Information enthalten ist (default: `name`) mit `group_by` und berechne den Mittelwert der Temperatur pro Sensor (`summarise`). Hinweis: Beide Funktionen sind Teil des Packages `dplyr`.\n\nDer Output sieht folgendermassen aus: \n\n\n::: {.cell}\n\n```\n## # A tibble: 3 × 2\n##   name    temp_mean\n##   <chr>       <dbl>\n## 1 sensor1      14.7\n## 2 sensor2      12.0\n## 3 sensor3      14.4\n```\n:::\n\n\n## Aufgabe 4\n\nErstelle für `sensors_long` eine neue *convenience* Variabel `month`, welche den Monat beinhaltet (Tipp: verwende dazu die Funktion `month` aus `lubridate`). Gruppiere nun nach `month` *und* Sensor und berechne den Mittelwert der Temperatur. \n\n\n::: {.cell}\n\n:::\n\n\n## Aufgabe 5\n\nLade jetzt nochmal den Datensatz *weather.csv* (Quelle MeteoSchweiz) herunter und importiere ihn als CSV mit den korrekten Spaltentypen (`stn` als `factor`, `time` als `POSIXct`, `tre200h0` als `double`).\n\n\n::: {.cell}\n\n:::\n\n\n## Aufgabe 6\n\nErstelle nun eine *convenience Variable* für die Kalenderwoche pro Messung (`lubridate::week`). Berechne im Anschluss den Mittelwert der Temperatur pro Kalenderwoche.\n\n\n::: {.cell}\n\n:::\n\n\nVisualisiere im Anschluss das Resultat:\n\n\n![](Prepro3_Uebung_files/figure-html/unnamed-chunk-7-1.png){width=672}\n\n\n## Aufgabe 7\n\nIn der vorherigen Aufgabe haben wir den Mittelwert der Temperatur pro Kalenderwoche über *alle Jahre* (2000 und 2001) berechnet. Wenn wir die Jahre aber miteinander vergleichen wollen, müssen wir das Jahr als zusätzliche *convenience Variable* erstellen und danach gruppieren. Versuche dies mit den Wetterdaten und visualisiere den Output anschliessend.\n\n\n::: {.cell}\n\n:::\n\n::: {.cell}\n::: {.cell-output-display}\n![baseplot mag keine long tables und macht aus den beiden Jahren eine kontinuierliche Linie](Prepro3_Uebung_files/figure-html/fig-baseplot-ex7-1.png){#fig-baseplot-ex7 width=672}\n:::\n:::\n\n\n## Aufgabe 8\n\nÜberführe den Output aus der letzten Übung in eine *wide table*. Nun lassen sich die beiden Jahre viel besser miteinander vergleichen.\n\n\n::: {.cell}\n\n:::\n\n::: {.cell}\n::: {.cell-output-display}\n![](Prepro3_Uebung_files/figure-html/unnamed-chunk-11-1.png){width=672}\n:::\n:::\n",
    "supporting": [
      "Prepro3_Uebung_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}