{
  "hash": "200aefff7d88c3cf29421cba22b40486",
  "result": {
    "engine": "knitr",
    "markdown": "---\nlesson: RaumAn3\nthema: G-Funktion\nexecute: \n  echo: true   # set to true to show musterlösung\n  output: true # set to true to show musterlösung\ncode-fold: true\ncode-summary: \"Musterlösung\"\nknitr:\n  opts_chunk: \n    collapse: true  \n---\n\n\n# Rauman 3: Übung C (Optional)\n\nIn dieser optionalen Übung wollen wir die G-Function für Luftqualitäts-Messstellen und Rotmilan Bewegungen berechnen und vergleichen.\n\n## Aufgabe 1\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"false\"}\nlibrary(\"sf\")\nlibrary(\"dplyr\")\nlibrary(\"ggplot2\")\n\nrotmilan <- read_sf(\"datasets/rauman/rotmilan.gpkg\")\n\nschweiz <- read_sf(\"datasets/rauman/schweiz.gpkg\")\n\nluftqualitaet <- read_sf(\"datasets/rauman/luftqualitaet.gpkg\")\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"false\"}\nggplot(rotmilan) +\n  geom_sf(data = schweiz) +\n  geom_sf(aes(colour = timestamp), alpha = 0.2) +\n  scale_color_datetime(low = \"blue\", high = \"red\")\n```\n\n::: {.cell-output-display}\n![Eine solche Visualisierung zeigt dir beispielsweise die räumliche Ausdehnung der Datenpunkte](Rauman3_Uebung_C_files/figure-html/fig-ggplot-ex1-1.png){#fig-ggplot-ex1 width=672}\n:::\n:::\n\n\n## Aufgabe 2\n\nAls erstes berechnen wir die G-Function für die Rotmilanpositionen:\n\n### Schritt 1\n\nMit `st_distance()` können Distanzen zwischen zwei `sf`-Datensätze berechnet werden. Wird nur ein Datensatz angegeben, wird eine Kreuzmatrix erstellt, wo die Distanzen zwischen allen Features zu allen anderen Features dargestellt werden. Wir nützen diese Funktion zur Berechnung der nächsten Nachbarn.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrotmilan_distanzmatrix <- st_distance(rotmilan)\n\nnrow(rotmilan_distanzmatrix)\n## [1] 2305\nncol(rotmilan_distanzmatrix)\n## [1] 2305\n# zeige die ersten 6 Zeilen und Spalten der Matrix\n# jeder Wert ist 2x vorhanden (vergleiche Wert [2,1] mit [1,2])\n# die Diagonale ist die Distanz zu sich selber (gleich 0)\nrotmilan_distanzmatrix[1:6, 1:6]\n## Units: [m]\n##          1         2         3        4        5        6\n## 1     0.00 14362.044 20272.492 35596.07 52519.10 64156.67\n## 2 14362.04     0.000  8149.486 29752.74 44809.10 53775.25\n## 3 20272.49  8149.486     0.000 22580.04 36848.93 45662.55\n## 4 35596.07 29752.737 22580.037     0.00 17223.26 31439.57\n## 5 52519.10 44809.096 36848.926 17223.26     0.00 16499.19\n## 6 64156.67 53775.250 45662.554 31439.57 16499.19     0.00\n```\n:::\n\n\n### Schritt 2\n\nNun wollen wir wissen, wie gross die *kürzeste* Distanz von jedem Punkt zu seinem nächsten Nachbarn ist, also die *kürzeste Distanz pro Zeile*. Bevor wir diese ermitteln, müssen wir die diagonalen Werte noch entfernen, denn diese stellen ja jeweils die Distanz zu sich selber dar und sind immer `0`. Danach kann mit `apply()` eine Funktion (`FUN = min`) über die Zeilen (`MARGIN = 1`) einer Matrix (`X = rotmilan_distanzmatrix`) gerechnet werden. Zusätzlich müssen wir noch `na.rm = TRUE` setzen, damit `NA` Werte von der Berechnung ausgeschlossen werden. Das Resultat ist ein Vektor mit gleich vielen Werten wie Zeilen in der Matrix.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndiag(rotmilan_distanzmatrix) <- NA # entfernt alle diagonalen Werte\n\nrotmilan_distanzmatrix[1:6, 1:6]\n## Units: [m]\n##          1         2         3        4        5        6\n## 1       NA 14362.044 20272.492 35596.07 52519.10 64156.67\n## 2 14362.04        NA  8149.486 29752.74 44809.10 53775.25\n## 3 20272.49  8149.486        NA 22580.04 36848.93 45662.55\n## 4 35596.07 29752.737 22580.037       NA 17223.26 31439.57\n## 5 52519.10 44809.096 36848.926 17223.26       NA 16499.19\n## 6 64156.67 53775.250 45662.554 31439.57 16499.19       NA\n\nrotmilan_mindist <- apply(rotmilan_distanzmatrix, 1, min, na.rm = TRUE)\n```\n:::\n\n\n### Schritt 3\n\nNun müssen wir die Distanzen nach ihrer Grösse sortieren.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrotmilan_mindist <- sort(rotmilan_mindist)\n```\n:::\n\n\n### Schritt 4\n\nJetzt berechnen wir die kummulierte Häufigkeit von jeder Distanz. Die kummulierte Häufikgeit vom ersten Wert ist 1 (der Index des ersten Wertes) dividiert durch die Anzahl Werte insgesamt. Mit `seq_along` erhalten wir die Indizes aller Werte, mit `length` die Anzahl Werte insgesamt.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nkumm_haeufgikeit <- seq_along(rotmilan_mindist) / length(rotmilan_mindist)\n```\n:::\n\n\n### Schritt 5\n\nNun wollen wir die kumulierte Häufigkeit der Werte in einer Verteilungsfunktion (engl: [Empirical Cumulative Distribution Function, ECDF](https://en.wikipedia.org/wiki/Empirical_distribution_function)) darstellen. Dafür müssen wir die beiden Vektoren zuerst noch in einen Dataframe packen, damit `ggplot` damit klar kommt. \n\n\n::: {.cell}\n\n```{.r .cell-code}\nrotmilan_mindist_df <- data.frame(\n  distanzen = rotmilan_mindist,\n  kumm_haeufgikeit = kumm_haeufgikeit\n)\n\np <- ggplot() +\n  geom_line(data = rotmilan_mindist_df, aes(distanzen, kumm_haeufgikeit)) +\n  labs(x = \"Distanz (Meter)\", y = \"Häufigkeit (kummuliert)\")\np\n```\n\n::: {.cell-output-display}\n![](Rauman3_Uebung_C_files/figure-html/unnamed-chunk-7-1.png){width=672}\n:::\n:::\n\n\nLesehilfe:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nprob <- 0.95\nres <- quantile(ecdf(rotmilan_mindist_df$distanzen), prob)\nres2 <- quantile(ecdf(rotmilan_mindist_df$distanzen), 0.99)\nxlim <- c(5000, NA)\nylim <- c(.5, .75)\np +\n  geom_segment(aes(x = res, xend = res, y = -Inf, yend = prob), colour = \"lightblue\") +\n  geom_segment(aes(x = -Inf, xend = res, y = prob, yend = prob), colour = \"lightblue\") +\n  geom_point(aes(x = res, y = prob), size = 3, colour = \"lightblue\") +\n  ggrepel::geom_label_repel(aes(x = 0, y = prob, label = paste0(prob * 100, \"% der Werte...\")),\n    xlim = xlim, ylim = ylim, hjust = 0, min.segment.length = 0, fill = \"lightblue\"\n  ) +\n  ggrepel::geom_label_repel(aes(x = res, y = 0, label = paste0(\"... sind kleiner als \", round(res, 0), \"m\")),\n    xlim = xlim, ylim = ylim, hjust = 0, vjust = 1, fill = \"lightblue\", min.segment.length = 0, inherit.aes = FALSE\n  ) +\n  scale_y_continuous(breaks = c(0, .25, .5, .75, prob, 1))\n```\n\n::: {.cell-output-display}\n![](Rauman3_Uebung_C_files/figure-html/unnamed-chunk-8-1.png){width=672}\n:::\n:::\n\n\n## Aufgabe 3\n\nFühre nun die gleichen Schritte mit `luftqualitaet` durch und vergleiche die ECDF-Plots. \n\n\n::: {.cell}\n\n```{.r .cell-code}\nluftqualitaet_distanzmatrix <- st_distance(luftqualitaet)\n\ndiag(luftqualitaet_distanzmatrix) <- NA\n\nluftqualitaet_mindist <- apply(luftqualitaet_distanzmatrix, 1, min, na.rm = TRUE)\n\nluftqualitaet_mindist <- sort(luftqualitaet_mindist)\n\nkumm_haeufgikeit_luftquali <- seq_along(luftqualitaet_mindist) / length(luftqualitaet_mindist)\n\nluftqualitaet_mindist_df <- data.frame(\n  distanzen = luftqualitaet_mindist,\n  kumm_haeufgikeit = kumm_haeufgikeit_luftquali\n)\n\nluftqualitaet_mindist_df$data <- \"Luftqualitaet\"\nrotmilan_mindist_df$data <- \"Rotmilan\"\n\nmindist_df <- rbind(luftqualitaet_mindist_df, rotmilan_mindist_df)\n\nggplot(mindist_df, ) +\n  geom_line(aes(distanzen, kumm_haeufgikeit, colour = data)) +\n  labs(x = \"Distanz (Meter)\", y = \"Häufigkeit (kummuliert)\", colour = \"Datensatz\")\n```\n\n::: {.cell-output-display}\n![](Rauman3_Uebung_C_files/figure-html/unnamed-chunk-9-1.png){width=672}\n:::\n:::\n",
    "supporting": [
      "Rauman3_Uebung_C_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}