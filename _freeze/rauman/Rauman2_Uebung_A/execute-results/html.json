{
  "hash": "1ce16796e81d59cceaf6d63185485b38",
  "result": {
    "engine": "knitr",
    "markdown": "---\nlesson: RaumAn2\nthema: Vector Data\nexecute: \n  echo: true   # set to true to show musterlösung\n  output: true # set to true to show musterlösung\ncode-fold: true\ncode-summary: \"Musterlösung\"\nknitr:\n  opts_chunk: \n    collapse: true  \n---\n\n\n# Rauman 2: Übung A\n\nIn [der letzten Übung](#sec-rauman1b) haben wir einen Spatial Join zwischen Bäumen und Wiesen durchgeführt, um herauszufinden, ob sich der Baum in einer Wiese befindet oder nicht. Basis waren dafür die Daten vom Campus Grüental (*gruental.gpkg*)\n\nHeute gehen wir einen Schritt weiter und wollen folgende Frage beantworten: *Wie viel Wiese befinden sich in einem Umkreis von 20m um jeden Baum?*\n\nLade dazu die benötigten Libraries und Datensätze in deine Session. Exploriere die Daten und visualisiere sie räumlich.\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"false\"}\nlibrary(\"dplyr\")\nlibrary(\"sf\")\nlibrary(\"ggplot2\")\n\nwiesen <- read_sf(\"datasets/rauman/gruental.gpkg\", \"wiesen\")\nbaeume <- read_sf(\"datasets/rauman/gruental.gpkg\", \"baeume\")\n```\n:::\n\n\nUm die Übung etwas zu vereinfachen, arbeiten wir erstmals mit nur 10 Bäumen. Diese Bäume befinden sich im Shapefile *baume_sample.shp* (auf Moodle). \n\n:::{.callout-note}\n\nEin Shapefile ist ein häufig verwendetes, aber inzwischen veraltetes Dateiformat für Geodaten. Es besteht aus mehreren Dateien (`.shp`, `.shx`, `.prj`...), die zusammen die Geometrie und Attribute von Geodaten speichern. \n\n:::\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"false\"}\nbaeume_sample <- read_sf(\"datasets/rauman/baeume_sample.shp\")\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"false\"}\nggplot() +\n  geom_sf(data = wiesen) +\n  geom_sf(data = baeume_sample)\n```\n\n::: {.cell-output-display}\n![](Rauman2_Uebung_A_files/figure-html/unnamed-chunk-3-1.png){width=672}\n:::\n:::\n\n\n## Aufgabe 1\n\nAls erster Schritt müssen wir jeden Baum mit einem 20m Puffer versehen. Nutze dazu `st_buffer` und speichere den Output als `baeume_20m`. Schau dir `baeume_20m` nun genau an. Um welchen Geometrietyp handelt es sich dabei nun?\n\n\n::: {.cell}\n\n```{.r .cell-code}\nbaeume_20m <- st_buffer(baeume_sample, 20)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot() +\n  geom_sf(data = wiesen) +\n  geom_sf(data = baeume_sample) +\n  geom_sf(data = baeume_20m, fill = NA)\n```\n\n::: {.cell-output-display}\n![Dargestellt sind die Bäume als Punkte mit einem 20m Puffer, sowie die Wiesen im Hintergrund.](Rauman2_Uebung_A_files/figure-html/fig-buffer1-1.png){#fig-buffer1 width=672}\n:::\n:::\n\n\n## Aufgabe 2\n\nBerechnen nun die Schnittmenge aus `baeume_20m` und `wiesen` mit der Funktion `st_intersection` und speichere den Output als `baeume_wiesen`. Exploriere nun `baeume_wiesen`. Was ist passiert? Überprüfe die Anzahl Zeilen pro Datensatz. Haben die sich verändert? Wenn ja, warum?\n\n\n::: {.cell}\n\n```{.r .cell-code}\nbaeume_wiesen <- st_intersection(baeume_20m, wiesen)\n\nggplot() +\n  geom_sf(data = wiesen, fill = \"blue\", alpha = .2) +\n  geom_sf(data = baeume_20m, fill = \"red\", alpha = .2) +\n  geom_sf(data = baeume_wiesen, fill = \"green\", alpha = 0.2)\n```\n\n::: {.cell-output-display}\n![](Rauman2_Uebung_A_files/figure-html/unnamed-chunk-6-1.png){width=672}\n:::\n:::\n\n\n## Aufgabe 3\n\nBerechnen nun die Flächengrösse pro Geometrie mit der Funktion `st_area()`. Speichere den Output in einer neuen Spalte von `baeume_wiesen` (z.B. mit dem Namen `wiesen_flaeche`). Tipp: Konvertiere den Output aus `st_area` in einen nummerischen Vektor mit `as.numeric()`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nbaeume_wiesen$wiesen_flaeche <- as.numeric(st_area(baeume_wiesen))\n```\n:::\n\n\n## Aufgabe 4 (Optional)\n\nBerechne nun aus `wiesen_flaeche` den `wiesen_anteil`. Tipp: 100% ist die Kreisfläche aus $r^2\\times \\pi$, wobei in unserem Fall $r = 20$ entspricht.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nkreisflaeche <- 20^2 * pi\nbaeume_wiesen$wiesen_anteil <- baeume_wiesen$wiesen_flaeche / kreisflaeche\n```\n:::\n\n\nÜberführe anschliessend die berechneten Anteilswerte in den Datensatz `baeume` mit einem `left_join` zwischen `baeume` und `baeume_wiesen`. Welche Spalte wäre für diesen Join geeignet? Hinweis: Nutze `st_drop_geometry()`, um die Geometriespalte in `baeme_wiesen` vor dem Join zu entfernen.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nbaeume_wiesen_df <- st_drop_geometry(baeume_wiesen)\n\nbaeume_2 <- left_join(baeume_sample, baeume_wiesen_df, by = \"baum_id\")\n\nggplot() +\n  geom_sf(data = wiesen) +\n  geom_sf(data = baeume_2, aes(colour = wiesen_anteil)) +\n  scale_color_binned(\"Wiesen Anteil\", low = \"blue\", high = \"red\", limits = c(0, 1), label = scales::label_percent()) +\n  coord_sf(datum = 2056)\n```\n\n::: {.cell-output-display}\n![Nach dieser Übung kannst du das Resultat in dieser Weise visualisieren.](Rauman2_Uebung_A_files/figure-html/fig-ggplot-ex4-1.png){#fig-ggplot-ex4 width=672}\n:::\n:::\n\n\n## Aufgabe 5 {#sec-raster-intro1}\n\nNun habt ihr ein paar Vektoroperationen wie `st_buffer()`, `st_intersection()` und `st_area()` durchgeführt. Gewisse Fragen lassen sich aber besser in der Raster-Welt beantworten. Wollen wir beispielsweise für jeden Punkt im Raum wissen, wie weit der nächstgelegene Baum ist, lässt sich das besser in einem Raster darstellen.\n\nBevor wir die Frage aber beantworten können, müssen wir den Vektordatensatz in ein Rasterdatensatz konvertieren. Dafür wiederum braucht es ein Raster \"Template\", damit R in etwa weiss, wie der Raster-Output auszusehen hat. \n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"false\"}\n\n# Um mit Raster arbeiten zu können brauchen wir das Package \"terra\"\nlibrary(\"terra\")\n\n# Um ein Vektor Datensatz zu vektorieren, brauchen wir ein Template.\n# Für das Template nutzen wir \"wiesen\" und setzen eine Zellgrösse (resolution)\ntemplate <- rast(wiesen, resolution = 20)\n\n# Mit rasterize können wir \"baeume\" in einen Raster konvertieren\n# Nutzt hier wieder alle bäume, nicht baeume_sample\nbaeume_rast <- terra::rasterize(baeume, template)\n```\n:::\n\n\nDer Unterschied zwischen Raster und Vektor kann sehr anschaulich dargestellt werden, wenn die beiden Datensätze übereinander gelagert werden.\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"false\"}\nplot(baeume_rast, col = \"grey\")\nplot(baeume, add = TRUE, col = \"red\", pch = \"x\")\n```\n\n::: {.cell-output-display}\n![](Rauman2_Uebung_A_files/figure-html/unnamed-chunk-11-1.png){width=672}\n:::\n:::\n\n\nMit `baeume_rast` können wir nun mit der Funktion `distance()` die Distanz zu jedem Baum berechnen:\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"false\"}\n\nbaeume_dist <- distance(baeume_rast)\nplot(baeume_dist)\nplot(baeume, add = TRUE, pch = \"x\")\n```\n\n::: {.cell-output-display}\n![](Rauman2_Uebung_A_files/figure-html/unnamed-chunk-12-1.png){width=672}\n:::\n:::\n",
    "supporting": [
      "Rauman2_Uebung_A_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}