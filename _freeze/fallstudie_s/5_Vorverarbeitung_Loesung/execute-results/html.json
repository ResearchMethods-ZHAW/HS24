{
  "hash": "054b0ea1339dbad5e6e0ca053a5b0144",
  "result": {
    "markdown": "# KW 42+43: Lösung Datenvorverarbeitung\n\n\n\n\n\n\n\n\n# Aufgabe 1: Zähldaten\n\n\n::: {.cell layout-align=\"left\"}\n\n```{.r .cell-code}\n# lese die Daten ein \n# Je nach Bedarf muss der Speicherort sowie der Dateiname angepasst werden\ndepo <- read.csv(\"datasets/fallstudie_s/WPZ/211_sihlwaldstrasse_2017_2022.csv\", sep = \";\")\n\n# Hinweis zu den Daten:\n# In hourly analysis format, the data at 11:00 am corresponds to the counts saved between \n# 11:00 am and 12:00 am.\n\n# Anpassen der Datentypen und erstes Sichten\nstr(depo)\n\ndepo <- depo |>\n  mutate(Datum = as.character(Datum)) |> \n  mutate(Datum = as.Date(Datum, format = \"%Y%m%d\")) #|> \n  # Schneide das df auf den gewuenschten Zeitraum zu\n  # filter(Datum >= depo_start, Datum <=  depo_end) # das Komma hat die gleiche Funktion wie ein &\n\n# In dieser Auswertung werden nur Personen zu Fuss betrachtet!\n# it select werden spalten ausgewaehlt oder eben fallengelassen\ndepo <- depo |> dplyr::select(-c(Velo_IN, Velo_OUT))\n\n# Berechnen des Totals, da dieses in den Daten nicht vorhanden ist\ndepo <- depo|>\n  mutate(Total = Fuss_IN + Fuss_OUT)\n\n# Entferne die NA's in dem df.\ndepo <- na.omit(depo)\n```\n:::\n\n\n# Aufgabe 2: Meteodaten\n\n\n::: {.cell layout-align=\"left\"}\n\n```{.r .cell-code}\n# Einlesen\nmeteo <- read.csv(\"datasets/fallstudie_s/WPZ/order_105742_data.txt\", sep = \";\")\n\n# Datentypen setzen\n# Das Datum wird als Integer erkannt. Zuerst muss es in Text umgewaldelt werden aus dem dann\n# das eigentliche Datum herausgelesen werden kann\nmeteo <- transform(meteo, time = as.Date(as.character(time), \"%Y%m%d\"))\n\n# Die eigentlichen Messwerte sind alle nummerisch\nmeteo <- meteo|>\n  mutate(tre200jx = as.numeric(tre200jx))|>\n  mutate(rre150j0 = as.numeric(rre150j0))|>\n  mutate(sremaxdv = as.numeric(sremaxdv)) |> \n  filter(time >= depo_start, time <=  depo_end) # schneide dann auf Untersuchungsdauer\n\n# Was ist eigentlich Niederschlag:\n# https://www.meteoschweiz.admin.ch/home/wetter/wetterbegriffe/niederschlag.html\n\n# Filtere Werte mit NA\nmeteo <- meteo |>\n  filter(!is.na(stn)) |>\n  filter(!is.na(time))|>\n  filter(!is.na(tre200jx))|>\n  filter(!is.na(rre150j0))|>\n  filter(!is.na(sremaxdv))\n# Pruefe ob alles funktioniert hat\nstr(meteo)\nsum(is.na(meteo)) # zeigt die Anzahl NA's im data.frame an\n```\n:::\n\n\n# Aufgabe 3: Datenvorverarbeitung (Mutationen)\n\n\n::: {.cell layout-align=\"left\"}\n\n```{.r .cell-code}\n#.################################################################################################\n# 2. VORBEREITUNG DER DATEN #####\n#.################################################################################################\n\n# 2.1 Convinience Variablen ####\n# fuege dem Dataframe (df) die Wochentage hinzu\ndepo <- depo |> \n  mutate(Wochentag = weekdays(Datum)) |> \n  # R sortiert die Levels aplhabetisch. Da das in unserem Fall aber sehr unpraktisch ist,\n  # muessen die Levels manuell manuell bestimmt werden\n  mutate(Wochentag = base::factor(Wochentag, \n                            levels = c(\"Montag\", \"Dienstag\", \"Mittwoch\", \n                                       \"Donnerstag\", \"Freitag\", \"Samstag\", \"Sonntag\"))) |> \n  # Werktag oder Wochenende hinzufuegen\n  mutate(Wochenende = if_else(Wochentag == \"Montag\" | Wochentag == \"Dienstag\" | \n                           Wochentag == \"Mittwoch\" | Wochentag == \"Donnerstag\" | \n                           Wochentag == \"Freitag\", \"Werktag\", \"Wochenende\"))|>\n  #Kalenderwoche hinzufuegen\n  mutate(KW= isoweek(Datum))|>\n  # monat und Jahr\n  mutate(Monat = month(Datum)) |> \n  mutate(Jahr = year(Datum))\n\n#Lockdown \n# Hinweis: ich mache das nachgelagert, da ich die Erfahrung hatte, dass zu viele \n# Operationen in einem Schritt auch schon mal durcheinander erzeugen koennen.\n# Hinweis II: Wir packen alle Phasen (normal, die beiden Lockdowns und Covid aber ohne Lockdown)\n# in eine Spalte --> long ist schoener als wide\ndepo <- depo |>\n  mutate(Phase = if_else(Datum >= lock_1_start_2020 & Datum <= lock_1_end_2020,\n                         \"Lockdown_1\",\n                         if_else(Datum >= lock_2_start_2021 & Datum <= lock_2_end_2021,\n                                 \"Lockdown_2\",\n                                 if_else(Datum>= (lock_1_start_2020 - years(1)) & Datum < lock_1_start_2020,\n                                         \"Normal\", \n                                         if_else(Datum > lock_2_end_2021,\n                                                 \"Post\", \"Pre\")))))\n\n# hat das gepklappt?!\nunique(depo$Phase)\n\n# aendere die Datentypen\ndepo <- depo |> \n  mutate(Wochenende = as.factor(Wochenende)) |> \n  mutate(KW = factor(KW)) |> \n  # mit factor() koennen die levels direkt einfach selbst definiert werden.\n  # wichtig: speizfizieren, dass aus R base, ansonsten kommt es zu einem \n  # mix-up mit anderen packages\n  mutate(Phase = base::factor(Phase, levels = c(\"Pre\", \"Normal\", \"Lockdown_1\", \"Lockdown_2\", \"Post\")))\n\nstr(depo)\n  \n# Fuer einige Auswertungen muss auf die Stunden als nummerischer Wert zurueckgegriffen werden\ndepo$Stunde <- as.numeric(format(as.POSIXct(depo$Zeit,format=\"%H:%M:%S\"),\"%H\"))\n\n# ersetze 0 Uhr mit 24 Uhr (damit wir besser rechnen können)\ndepo$Stunde[depo$Stunde == 0] <- 24\nunique(depo$Stunde)\ntypeof(depo$Stunde)\n\n# Die Daten wurden kalibriert. Wir runden sie fuer unserer Analysen auf Ganzzahlen\ndepo$Total <- round(depo$Total, digits = 0)\ndepo$Fuss_IN <- round(depo$Fuss_IN, digits = 0)\ndepo$Fuss_OUT <- round(depo$Fuss_OUT, digits = 0)\n\n# 2.2 Tageszeit hinzufuegen ####\n\n# Einteilung Standort Zuerich\nLatitude <- 47.38598\nLongitude <- 8.50806\n\n# Zur Berechnung der Tageslaege muessen wir zuerst den Start und das Ende der Sommer-\n# zeit definieren\n# https://www.schulferien.org/schweiz/zeit/zeitumstellung/\n\nSo_start_2017 <- as.Date(\"2017-03-26\") \nSo_end_2017 <- as.Date(\"2017-10-29\") \nSo_start_2018 <- as.Date(\"2018-03-25\") \nSo_end_2018 <- as.Date(\"2018-10-28\") \nSo_start_2019 <- as.Date(\"2019-03-31\") \nSo_end_2019 <- as.Date(\"2019-10-27\") \nSo_start_2020 <- as.Date(\"2020-03-29\")\nSo_end_2020 <- as.Date(\"2020-10-25\")\nSo_start_2021 <- as.Date(\"2021-03-28\")\nSo_end_2021 <- as.Date(\"2021-10-31\")\nSo_start_2022 <- as.Date(\"2022-03-27\")\nSo_end_2022 <- as.Date(\"2022-10-30\")\n\n# Welche Zeitzone haben wir eigentlich?\n# Switzerland uses Central European Time (CET) during the winter as standard time, \n# which is one hour ahead of Coordinated Universal Time (UTC+01:00), and \n# Central European Summer Time (CEST) during the summer as daylight saving time, \n# which is two hours ahead of Coordinated Universal Time (UTC+02:00).\n# https://en.wikipedia.org/wiki/Time_in_Switzerland\n\n# Was sind Astronomische Dämmerung und Golden Hour ueberhaupt?\n# https://sunrisesunset.de/sonne/schweiz/zurich-kreis-1-city/\n# https://www.rdocumentation.org/packages/suncalc/versions/0.5.0/topics/getSunlightTimes\n\n# Wir arbeiten mit folgenden Variablen:\n# \"nightEnd\" : night ends (morning astronomical twilight starts)\n# \"goldenHourEnd\" : morning golden hour (soft light, best time for photography) ends\n# \"goldenHour\" : evening golden hour starts\n# \"night\" : night starts (dark enough for astronomical observations)\n\nlumidata <-\n  getSunlightTimes(\n    date = seq.Date(depo_start, depo_end, by = 1),\n    keep = c(\"nightEnd\", \"goldenHourEnd\", \"goldenHour\", \"night\"),\n    lat = Latitude,\n    lon = Longitude,\n    tz = \"CET\")\n\nlumidata <- lumidata |> \n  mutate(Jahreszeit = ifelse(date >= So_start_2017 & date <=  So_end_2017 |\n                               date >= So_start_2018 & date <=  So_end_2018 |\n                               date >= So_start_2019 & date <=  So_end_2019 |\n                               date >= So_start_2020 & date <= So_end_2020 |\n                               date >= So_start_2021 & date <= So_end_2021 |\n                               date >= So_start_2022 & date <= So_end_2022, \n                               \"Sommerzeit\", \"Winterzeit\"))\n\n# CH ist im Im Sommer CET + 1. \n# Darum auf alle relevanten Spalten eine Stunde addieren\n# hinweis: ich verzichte hier auf ifelse, da es einfacher und nachvollziehbarer scheint,\n# hier mit einem filter die betreffenden Spalten zu waehlen\nlumidata_So <- lumidata |> \n  filter(Jahreszeit==\"Sommerzeit\") |> \n  mutate(nightEnd = nightEnd + hours(1),\n         goldenHourEnd =  goldenHourEnd + hours(1),\n         goldenHour = goldenHour + hours(1),\n         night = night + hours(1))\n\nlumidata_Wi <- lumidata |> \n  filter(Jahreszeit==\"Winterzeit\") \n# verbinde sommer- und winterzeit wieder\nlumidata <- rbind(lumidata_So, lumidata_Wi) |> \n  arrange(date)\n\n# change data type\nlumidata$date <- as.Date(lumidata$date, format= \"%Y-%m-%d\")\n\n# drop unnecessary cols\nlumidata <- lumidata |> dplyr::select(-lat, -lon)\n\n# jetzt haben wir alle noetigen Angaben zu Sonnenaufgang, Tageslaenge usw. \n# diese Angaben koennen wir nun mit unseren Zaehldaten verbinden:\ndepo <- left_join(depo,lumidata, by = c(\"Datum\" =\"date\"))\n\n# aendere alle Zeit- und Datumsangaben so, dass sie gleich sind und miteinander verrechnet werden können.\ndepo <- depo |> \n  mutate(datetime = paste(Datum, Zeit)) |> \n  mutate(datetime = as.POSIXct(datetime, format = \"%Y-%m-%d  %H:%M:%S\"))|> \n  mutate(nightEnd = as.POSIXct(nightEnd)) |> \n  mutate(goldenHourEnd = as.POSIXct(goldenHourEnd)) |> \n  mutate(goldenHourEnd = goldenHourEnd + hours(1)) |> \n  mutate(goldenHour = as.POSIXct(goldenHour)) |> \n  mutate(goldenHour = goldenHour - hours(1)) |> \n  mutate(night = as.POSIXct(night))\n\n# im naechsten Schritt weise ich den Stunden die Tageszeiten Morgen, Tag, Abend und Nacht zu.\n# diese Zuweisung basiert auf der Einteilung gem. suncalc und eigener Definition.\ndepo <- depo|>\n  mutate(Tageszeit = if_else(datetime >= nightEnd & datetime <= goldenHourEnd, \"Morgen\",\n                             ifelse(datetime > goldenHourEnd & datetime < goldenHour, \"Tag\",\n                                    ifelse(datetime >= goldenHour & datetime <= night,\n                                           \"Abend\",\n                                           \"Nacht\")))) |>\n  mutate(Tageszeit = factor(Tageszeit, levels = c(\n    \"Morgen\", \"Tag\", \"Abend\", \"Nacht\")))\n\n# # behalte die relevanten Var\ndepo <- depo |> dplyr::select(-nightEnd, -goldenHourEnd, -goldenHour, -night)\n\n#Plotte zum pruefn ob das funktioniert hat\np <- ggplot(depo, aes(y = Datum, color = Tageszeit, x = Stunde))+\n  geom_jitter()+\n  scale_color_manual(values=mycolors)\n\nplotly::ggplotly(p)\n```\n:::\n\n::: {.cell layout-align=\"left\"}\n\n```{.r .cell-code}\n# bei mir hat der Zusatz der Tageszeit noch zu einigen NA-Wertren gefueht. \n# Diese loesche ich einfach:\ndepo <- na.omit(depo)\n# hat das funktioniert?\nsum(is.na(depo))\n```\n:::\n\n\n# Aufgabe 4: Aggregierung der Stundendaten\n\n\n::: {.cell layout-align=\"left\"}\n\n```{.r .cell-code}\n# 2.4 Aggregierung der Stundendaten zu ganzen Tagen ####\n# Zur Berechnung von Kennwerten ist es hilfreich, wenn neben den Stundendaten auch auf Ganztagesdaten\n# zurueckgegriffen werden kann\n# hier werden also pro Nutzergruppe und Richtung die Stundenwerte pro Tag aufsummiert\ndepo_d <- depo |> \n  group_by(Datum, Wochentag, Wochenende, KW, Monat, Jahr, Phase) |> \n  summarise(Total = sum(Fuss_IN + Fuss_OUT), \n            Fuss_IN = sum(Fuss_IN),\n            Fuss_OUT = sum(Fuss_OUT)) \n# Wenn man die Convinience Variablen als grouping variable einspeisst, dann werden sie in \n# das neue df uebernommen und muessen nicht nochmals hinzugefuegt werden\n# pruefe das df\nhead(depo_d)\n\n# nun gruppieren wir nicht nur nach Tag sondern auch noch nach Tageszeit\ndepo_daytime <- depo |> \n  group_by(Datum, Wochentag, Wochenende, KW, Monat, Jahr, Phase, Tageszeit) |> \n  summarise(Total = sum(Fuss_IN + Fuss_OUT), \n            Fuss_IN = sum(Fuss_IN),\n            Fuss_OUT = sum(Fuss_OUT)) \n\n\n# Gruppiere die Werte nach Monat\ndepo_m <- depo |> \n  group_by(Jahr, Monat) |> \n  summarise(Total = sum(Total)) \n# sortiere das df aufsteigend (nur das es sicher stimmt)\ndepo_m <- as.data.frame(depo_m)\ndepo_m[\n  with(depo_m, order(Jahr, Monat)),]\ndepo_m <- depo_m |> \n  mutate(Ym = paste(Jahr, Monat)) |> # und mache eine neue Spalte, in der Jahr und\n  mutate(Ym= lubridate::ym(Ym)) # formatiere als Datum\n\n# Gruppiere die Werte nach Monat und TAGESZEIT\ndepo_m_daytime <- depo |> \n  group_by(Jahr, Monat, Tageszeit) |> \n  summarise(Total = sum(Total)) \n# sortiere das df aufsteigend (nur das es sicher stimmt)\ndepo_m_daytime <- as.data.frame(depo_m_daytime)\ndepo_m_daytime[\n  with(depo_m_daytime, order(Jahr, Monat)),]\ndepo_m_daytime <- depo_m_daytime |> \n  mutate(Ym = paste(Jahr, Monat)) |> # und mache eine neue Spalte, in der Jahr und\n  mutate(Ym= lubridate::ym(Ym)) # formatiere als Datum\n```\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}