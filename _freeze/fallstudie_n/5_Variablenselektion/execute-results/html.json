{
  "hash": "386469fac8993fe48a6ac11c76f8e322",
  "result": {
    "engine": "knitr",
    "markdown": "---\nexecute:\n  echo: false  # set to true to show musterlösung\n  output: false # set to true to show musterlösung\ncode-fold: true\ncode-summary: \"Musterlösung\"\nknitr:\n  opts_chunk: \n    collapse: true\n---\n\n\n# Variablenselektion Multivariate Modelle\n\n## Libraries laden\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"false\"}\nlibrary(\"sf\")\nlibrary(\"terra\")\nlibrary(\"dplyr\")\nlibrary(\"readr\")\nlibrary(\"ggplot2\")\nlibrary(\"PerformanceAnalytics\")\nlibrary(\"pastecs\")\nlibrary(\"lme4\")\nlibrary(\"bbmle\")\nlibrary(\"MuMIn\")\nlibrary(\"MASS\")\n```\n:::\n\n\n## Variablenselektion\n\n→ Vorgehen analog @coppes2017\n\n## Aufgabe 1\n\nMit dem folgenden Code kann eine simple Korrelationsmatrix aufgebaut werden, vergl. Aufgabe 5 vorangehende Woche \n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"false\"}\nDF_mod <- read_delim(\"datasets/fallstudie_n/Aufgabe4_Datensatz_Habitatnutzung_Modelle_241028.csv\", delim = \";\")\n\nDF_mod_day <- DF_mod |>\n  filter(time_of_day == \"day\")\n\nround(cor(DF_mod_day[, 5:12], method = \"pearson\"), 2)\n\n# hier kann die Schwelle für die Korrelation gesetzt werden, 0.7 ist eher liberal /\n# 0.5 konservativ\n\ncor <- round(cor(DF_mod_day[, 5:12], method = \"pearson\"), 2)\ncor[abs(cor) < 0.7] <- 0\ncor\n```\n:::\n\n\n## Aufgabe 2\n\nSkalieren der Variablen, damit ihr Einfluss vergleichbar wird (Befehl scale(); Problem verschiedene Skalen der Variablen (bspw. Neigung in Grad, Distanz in Metern));\nUmwandeln der Reh-ID in einen Faktor, damit dieser als Random Factor ins Model eingespiesen werden kann.\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"false\"}\nDF_mod_day <- DF_mod_day |>\n  mutate(\n    slope_scaled = scale(slope),\n    topo_pos_scaled = scale(topo_pos),\n    us_scaled = scale(us_2014),\n    os_scaled = scale(os_2014),\n    forest_prop_scaled = scale(forest_prop),\n    dist_road_trails_scaled = scale(dist_road_trails),\n    dist_road_only_scaled = scale(dist_road_only),\n    dist_sett_scaled = scale(dist_sett),\n    id = as.factor(id)\n  )\n```\n:::\n\n\n## Aufgabe 3\n\n**Selektion der Variablen in einem univariaten Model**\n\nEin erstes GLMM (Generalized Linear Mixed Effects Modell) aufbauen: Funktion und Modelformel\n\n> wichtige [Seite](https://bbolker.github.io/mixedmodels-misc/glmmFAQ.html) auf der man viele Hilfestellungen zu GLMM’s finden kann.\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"false\"}\n# wir werden das package lme4 mit der Funktion glmer verwenden\n\n# die Hilfe von glmer aufrufen: ?glmer\n\n# glmer(formula, data = , family = binomial)\n\n# 1) formula:\n# Abhängige Variable ~ Erklärende Variable + Random Factor\n# In unseren Modellen kontrollieren wir für individuelle Unterschiede bei den Rehen\n# indem wir einen Random Factor definieren => (1 | id)\n\n# 2) data:\n# euer Datensatz\n\n# 3) family:\n# hier binomial\n\n# warum binomial? Verteilung Daten der abhängigen Variable Präsenz/Absenz\n\nggplot(DF_mod_day, aes(pres_abs)) +\n  geom_histogram()\n\n# --> Binäre Verteilung => Binomiale Verteilung mit n = 1\n\n# und wie schaut die Verteilung der Daten der abhängigen Variable Nutzungsintensität\n# (nmb, werden wir in diesem Kurs aber nicht genauer anschauen) aus?\n```\n:::\n\n\n## Aufgabe 4\n\nMit der GLMM Formel bauen wir in einem ersten Schritt eine univariate Variablenselektion auf.\n\n***Als abhängige Variable verwenden wir die Präsenz/Absenz der Rehe in den Kreisen***\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"false\"}\n# Die erklärende Variable in m1 ist die erste Variable der korrelierenden Variablen\n# Die erklärende Variable in m2 ist die zweite Variable der korrelierenden Variablen\n\nm1 <- glmer(Abhaengige_Variable ~ Erklaerende_Variable + (1 | id),\n  data = DF_mod_day,\n  family = binomial\n)\n\nm2 <- glmer(Abhaengige_Variable ~ Erklaerende_Variable + (1 | id),\n  data = DF_mod_day,\n  family = binomial\n)\n\n# mit dieser Funktion können die Modellergebnisse inspiziert werden\nsummary(m1)\n\n# Mit dieser Funktion kann der Informationgehalt der beiden Modelle gegeneinander\n# abgeschätzt werden\nbbmle::AICtab(m1, m2)\n\n# tieferer AIC -> besser (AIC = Akaike information criterion)\n\n# ==> dieses Vorgehen muss nun für alle korrelierten Variablen für jeden Teildatensatz\n# (Tag/Nacht) durchgeführt werden, um nur noch nicht (R < 0.7) korrelierte Variablen\n# in das Modell einfliessen zu lassen\n```\n:::\n\n::: {.cell}\n\n:::\n\n\n## Aufgabe 5\n\n**Selektion der Variablen in einem multivariaten Model**\n\nMit folgendem Code kann eine automatisierte Variablenselektion (dredge-Funktion) und ein Modelaveraging aufgebaut werden (siehe auch Stats-Skript von J.Dengler & Team)\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"false\"}\n# hier wird die Formel für die dredge-Funktion vorbereitet (die Variablen V1-V8\n# sind jene welche nach der univariaten Variablenselektion noch übrig bleiben)\n\nf <- pres_abs ~\n  V1 +\n  V2 +\n  V3 +\n  V4 +\n  V5 +\n  V6 +\n  V7 +\n  V8\n\n# in diesem Befehl kommt der Random-Factor (das Reh) hinzu und es wird eine Formel\n# daraus gemacht\n\nf_dredge <- paste(c(f, \"+ (1 | id)\"), collapse = \" \") |> as.formula()\n\n# Das Modell mit dieser Formel ausführen\n\nm <- glmer(f_dredge, data = DF_mod_day, family = binomial, na.action = \"na.fail\")\n\n# Das Modell in die dredge-Funktion einfügen (siehe auch unbedingt ?dredge)\n\nall_m <- dredge(m)\n\n# Importance values der einzelnen Variablen (Gibt an, wie bedeutsam eine bestimmte\n# Variable ist, wenn man viele verschiedene Modelle vergleicht (multimodel inference))\n\nsw(all_m)\n\n# Schlussendlich wird ein Modelaverage durchgeführt (Schwellenwert für das delta-AIC = 2)\n\navgmodel <- model.avg(all_m, rank = \"AICc\", subset = delta < 2)\nsummary(avgmodel)\n\n# ==> für den Nachtdatensatz muss der gleiche Prozess der Variablenselektion\n# durchgespielt werden.\n```\n:::\n\n::: {.cell}\n\n:::\n\n::: {.cell}\n\n:::\n",
    "supporting": [
      "5_Variablenselektion_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}