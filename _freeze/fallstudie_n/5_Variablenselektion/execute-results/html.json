{
  "hash": "73afcc8af754813002f3b9363bc2735d",
  "result": {
    "engine": "knitr",
    "markdown": "---\nexecute:\n  echo: true  # set to true to show musterlösung\n  output: true # set to true to show musterlösung\ncode-fold: true\ncode-summary: \"Musterlösung\"\nknitr:\n  opts_chunk: \n    collapse: true\n---\n\n\n# Variablenselektion Multivariate Modelle\n\n## Libraries laden\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"false\"}\nlibrary(\"sf\")\nlibrary(\"terra\")\nlibrary(\"dplyr\")\nlibrary(\"readr\")\nlibrary(\"ggplot2\")\nlibrary(\"PerformanceAnalytics\")\nlibrary(\"pastecs\")\nlibrary(\"lme4\")\nlibrary(\"bbmle\")\nlibrary(\"MuMIn\")\nlibrary(\"MASS\")\n```\n:::\n\n\n## Variablenselektion\n\n→ Vorgehen analog @coppes2017\n\n## Aufgabe 1\n\nMit dem folgenden Code kann eine simple Korrelationsmatrix aufgebaut werden, vergl. Aufgabe 5 vorangehende Woche \n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"false\"}\nDF_mod <- read_delim(\"datasets/fallstudie_n/Aufgabe4_Datensatz_Habitatnutzung_Modelle_241028.csv\", delim = \";\")\n\nDF_mod_day <- DF_mod |>\n  filter(time_of_day == \"day\")\n\nround(cor(DF_mod_day[, 5:12], method = \"pearson\"), 2)\n##                  slope topo_pos dist_road_trails dist_road_only dist_sett\n## slope             1.00     0.09             0.31           0.34      0.14\n## topo_pos          0.09     1.00             0.06           0.09      0.08\n## dist_road_trails  0.31     0.06             1.00           0.93     -0.05\n## dist_road_only    0.34     0.09             0.93           1.00     -0.08\n## dist_sett         0.14     0.08            -0.05          -0.08      1.00\n## forest_prop       0.29     0.01            -0.03          -0.05      0.50\n## us_2014           0.28    -0.04             0.03           0.04      0.06\n## os_2014           0.45     0.06            -0.03          -0.01      0.34\n##                  forest_prop us_2014 os_2014\n## slope                   0.29    0.28    0.45\n## topo_pos                0.01   -0.04    0.06\n## dist_road_trails       -0.03    0.03   -0.03\n## dist_road_only         -0.05    0.04   -0.01\n## dist_sett               0.50    0.06    0.34\n## forest_prop             1.00    0.34    0.76\n## us_2014                 0.34    1.00    0.47\n## os_2014                 0.76    0.47    1.00\n\n# hier kann die Schwelle für die Korrelation gesetzt werden, 0.7 ist eher liberal /\n# 0.5 konservativ\n\ncor <- round(cor(DF_mod_day[, 5:12], method = \"pearson\"), 2)\ncor[abs(cor) < 0.7] <- 0\ncor\n##                  slope topo_pos dist_road_trails dist_road_only dist_sett\n## slope                1        0             0.00           0.00         0\n## topo_pos             0        1             0.00           0.00         0\n## dist_road_trails     0        0             1.00           0.93         0\n## dist_road_only       0        0             0.93           1.00         0\n## dist_sett            0        0             0.00           0.00         1\n## forest_prop          0        0             0.00           0.00         0\n## us_2014              0        0             0.00           0.00         0\n## os_2014              0        0             0.00           0.00         0\n##                  forest_prop us_2014 os_2014\n## slope                   0.00       0    0.00\n## topo_pos                0.00       0    0.00\n## dist_road_trails        0.00       0    0.00\n## dist_road_only          0.00       0    0.00\n## dist_sett               0.00       0    0.00\n## forest_prop             1.00       0    0.76\n## us_2014                 0.00       1    0.00\n## os_2014                 0.76       0    1.00\n```\n:::\n\n\n## Aufgabe 2\n\nSkalieren der Variablen, damit ihr Einfluss vergleichbar wird (Befehl scale(); Problem verschiedene Skalen der Variablen (bspw. Neigung in Grad, Distanz in Metern));\nUmwandeln der Reh-ID in einen Faktor, damit dieser als Random Factor ins Model eingespiesen werden kann.\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"false\"}\nDF_mod_day <- DF_mod_day |>\n  mutate(\n    slope_scaled = scale(slope),\n    topo_pos_scaled = scale(topo_pos),\n    us_scaled = scale(us_2014),\n    os_scaled = scale(os_2014),\n    forest_prop_scaled = scale(forest_prop),\n    dist_road_trails_scaled = scale(dist_road_trails),\n    dist_road_only_scaled = scale(dist_road_only),\n    dist_sett_scaled = scale(dist_sett),\n    id = as.factor(id)\n  )\n```\n:::\n\n\n## Aufgabe 3\n\n**Selektion der Variablen in einem univariaten Model**\n\nEin erstes GLMM (Generalized Linear Mixed Effects Modell) aufbauen: Funktion und Modelformel\n\n> wichtige [Seite](https://bbolker.github.io/mixedmodels-misc/glmmFAQ.html) auf der man viele Hilfestellungen zu GLMM’s finden kann.\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"false\"}\n# wir werden das package lme4 mit der Funktion glmer verwenden\n\n# die Hilfe von glmer aufrufen: ?glmer\n\n# glmer(formula, data = , family = binomial)\n\n# 1) formula:\n# Abhängige Variable ~ Erklärende Variable + Random Factor\n# In unseren Modellen kontrollieren wir für individuelle Unterschiede bei den Rehen\n# indem wir einen Random Factor definieren => (1 | id)\n\n# 2) data:\n# euer Datensatz\n\n# 3) family:\n# hier binomial\n\n# warum binomial? Verteilung Daten der abhängigen Variable Präsenz/Absenz\n\nggplot(DF_mod_day, aes(pres_abs)) +\n  geom_histogram()\n```\n\n::: {.cell-output-display}\n![](5_Variablenselektion_files/figure-html/unnamed-chunk-4-1.png){width=672}\n:::\n\n```{.r .cell-code  code-fold=\"false\"}\n\n# --> Binäre Verteilung => Binomiale Verteilung mit n = 1\n\n# und wie schaut die Verteilung der Daten der abhängigen Variable Nutzungsintensität\n# (nmb, werden wir in diesem Kurs aber nicht genauer anschauen) aus?\n```\n:::\n\n\n## Aufgabe 4\n\nMit der GLMM Formel bauen wir in einem ersten Schritt eine univariate Variablenselektion auf.\n\n***Als abhängige Variable verwenden wir die Präsenz/Absenz der Rehe in den Kreisen***\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"false\"}\n# Die erklärende Variable in m1 ist die erste Variable der korrelierenden Variablen\n# Die erklärende Variable in m2 ist die zweite Variable der korrelierenden Variablen\n\nmodell_1 <- glmer(Abhaengige_Variable ~ Erklaerende_Variable + (1 | id),\n  data = DF_mod_day,\n  family = binomial\n)\n\nmodell_2 <- glmer(Abhaengige_Variable ~ Erklaerende_Variable + (1 | id),\n  data = DF_mod_day,\n  family = binomial\n)\n\n# mit dieser Funktion können die Modellergebnisse inspiziert werden\nsummary(modell_1)\nsummary(modell_2)\n\n# Mit dieser Funktion kann der Informationgehalt der beiden Modelle gegeneinander\n# abgeschätzt werden\nbbmle::AICtab(modell_1, modell_2)\n\n# tieferer AIC -> besser (AIC = Akaike information criterion)\n\n# ==> dieses Vorgehen muss nun für alle korrelierten Variablen für jeden Teildatensatz\n# (Tag/Nacht) durchgeführt werden, um nur noch nicht (R < 0.7) korrelierte Variablen\n# in das Modell einfliessen zu lassen\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n\nmodell_1 <- glmer(pres_abs ~ dist_road_trails_scaled + (1 | id), data = DF_mod_day, family = binomial)\nmodell_2 <- glmer(pres_abs ~ dist_road_only_scaled + (1 | id), data = DF_mod_day, family = binomial)\n\nsummary(modell_1)\n## Generalized linear mixed model fit by maximum likelihood (Laplace\n##   Approximation) [glmerMod]\n##  Family: binomial  ( logit )\n## Formula: pres_abs ~ dist_road_trails_scaled + (1 | id)\n##    Data: DF_mod_day\n## \n##      AIC      BIC   logLik deviance df.resid \n##   5104.9   5123.7  -2549.4   5098.9     3961 \n## \n## Scaled residuals: \n##     Min      1Q  Median      3Q     Max \n## -2.1046 -0.7564 -0.6277  1.0812  1.9219 \n## \n## Random effects:\n##  Groups Name        Variance Std.Dev.\n##  id     (Intercept) 0.1996   0.4467  \n## Number of obs: 3964, groups:  id, 12\n## \n## Fixed effects:\n##                         Estimate Std. Error z value Pr(>|z|)    \n## (Intercept)             -0.31120    0.13418  -2.319   0.0204 *  \n## dist_road_trails_scaled  0.37745    0.03848   9.808   <2e-16 ***\n## ---\n## Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n## \n## Correlation of Fixed Effects:\n##             (Intr)\n## dst_rd_trl_ -0.004\nsummary(modell_2)\n## Generalized linear mixed model fit by maximum likelihood (Laplace\n##   Approximation) [glmerMod]\n##  Family: binomial  ( logit )\n## Formula: pres_abs ~ dist_road_only_scaled + (1 | id)\n##    Data: DF_mod_day\n## \n##      AIC      BIC   logLik deviance df.resid \n##   5098.4   5117.2  -2546.2   5092.4     3961 \n## \n## Scaled residuals: \n##     Min      1Q  Median      3Q     Max \n## -1.9625 -0.7615 -0.6080  1.0579  1.9425 \n## \n## Random effects:\n##  Groups Name        Variance Std.Dev.\n##  id     (Intercept) 0.2103   0.4586  \n## Number of obs: 3964, groups:  id, 12\n## \n## Fixed effects:\n##                       Estimate Std. Error z value Pr(>|z|)    \n## (Intercept)            -0.3024     0.1375  -2.199   0.0279 *  \n## dist_road_only_scaled   0.3950     0.0389  10.154   <2e-16 ***\n## ---\n## Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n## \n## Correlation of Fixed Effects:\n##             (Intr)\n## dst_rd_nly_ 0.002\n\nbbmle::AICtab(modell_1, modell_2)\n##          dAIC df\n## modell_2 0.0  3 \n## modell_1 6.5  3\n\n# tieferer AIC -> besser (AIC = Akaike information criterion) -> als deltaAIC ausgewiesen \n# Distanz zu Strassen (dist_road_only) = besser\n\n\nmodell_3 <- glmer(pres_abs ~ forest_prop_scaled + (1 | id), data = DF_mod_day, family = binomial)\nmodell_4 <- glmer(pres_abs ~ os_scaled + (1 | id), data = DF_mod_day, family = binomial)\n\nsummary(modell_3)\n## Generalized linear mixed model fit by maximum likelihood (Laplace\n##   Approximation) [glmerMod]\n##  Family: binomial  ( logit )\n## Formula: pres_abs ~ forest_prop_scaled + (1 | id)\n##    Data: DF_mod_day\n## \n##      AIC      BIC   logLik deviance df.resid \n##   4726.1   4745.0  -2360.1   4720.1     3961 \n## \n## Scaled residuals: \n##     Min      1Q  Median      3Q     Max \n## -2.2952 -0.7853 -0.3909  0.9056  3.4113 \n## \n## Random effects:\n##  Groups Name        Variance Std.Dev.\n##  id     (Intercept) 0.3069   0.554   \n## Number of obs: 3964, groups:  id, 12\n## \n## Fixed effects:\n##                    Estimate Std. Error z value Pr(>|z|)    \n## (Intercept)         -0.4351     0.1649  -2.639  0.00831 ** \n## forest_prop_scaled   0.8805     0.0443  19.878  < 2e-16 ***\n## ---\n## Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n## \n## Correlation of Fixed Effects:\n##             (Intr)\n## frst_prp_sc -0.060\nsummary(modell_4)\n## Generalized linear mixed model fit by maximum likelihood (Laplace\n##   Approximation) [glmerMod]\n##  Family: binomial  ( logit )\n## Formula: pres_abs ~ os_scaled + (1 | id)\n##    Data: DF_mod_day\n## \n##      AIC      BIC   logLik deviance df.resid \n##   4863.0   4881.9  -2428.5   4857.0     3961 \n## \n## Scaled residuals: \n##     Min      1Q  Median      3Q     Max \n## -2.0044 -0.7984 -0.4421  0.9854  2.8754 \n## \n## Random effects:\n##  Groups Name        Variance Std.Dev.\n##  id     (Intercept) 0.3228   0.5682  \n## Number of obs: 3964, groups:  id, 12\n## \n## Fixed effects:\n##             Estimate Std. Error z value Pr(>|z|)    \n## (Intercept) -0.34748    0.16847  -2.063   0.0392 *  \n## os_scaled    0.67559    0.03862  17.494   <2e-16 ***\n## ---\n## Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n## \n## Correlation of Fixed Effects:\n##           (Intr)\n## os_scaled -0.029\n\nbbmle::AICtab(modell_3, modell_4)\n##          dAIC  df\n## modell_3   0.0 3 \n## modell_4 136.9 3\n\n# tieferer AIC -> besser (AIC = Akaike information criterion) -> als deltaAIC ausgewiesen \n# Distanz zu Strassen (dist_road_only) = besser\n\n```\n:::\n\n\n## Aufgabe 5\n\n**Selektion der Variablen in einem multivariaten Model**\n\nMit folgendem Code kann eine automatisierte Variablenselektion (dredge-Funktion) und ein Modelaveraging aufgebaut werden (siehe auch Stats-Skript von J.Dengler & Team)\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"false\"}\n# hier wird die Formel für die dredge-Funktion vorbereitet (die Variablen V1-V6\n# sind jene welche nach der univariaten Variablenselektion noch übrig bleiben)\n\nf <- pres_abs ~\n  V1 +\n  V2 +\n  V3 +\n  V4 +\n  V5 +\n  V6 \n\n# in diesem Befehl kommt der Random-Factor (das Reh) hinzu und es wird eine Formel\n# daraus gemacht\n\nf_dredge <- paste(c(f, \"+ (1 | id)\"), collapse = \" \") |> as.formula()\n\n# Das Modell mit dieser Formel ausführen\n\nm <- glmer(f_dredge, data = DF_mod_day, family = binomial, na.action = \"na.fail\")\n\n# Das Modell in die dredge-Funktion einfügen (siehe auch unbedingt ?dredge)\n\nall_m <- dredge(m)\n\n# Importance values der einzelnen Variablen (Gibt an, wie bedeutsam eine bestimmte\n# Variable ist, wenn man viele verschiedene Modelle vergleicht (multimodel inference))\n\nsw(all_m)\n\n# Schlussendlich wird ein Modelaverage durchgeführt (Schwellenwert für das delta-AIC = 2)\n\navgmodel <- model.avg(all_m, rank = \"AICc\", subset = delta < 2)\nsummary(avgmodel)\n\n# ==> für den Nachtdatensatz muss der gleiche Prozess der Variablenselektion\n# durchgespielt werden.\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n# hier wird die Formel für die dredge-Funktion vorbereitet (die Variablen V1-V6\n# sind jene welche nach der univariaten Variablenselektion noch übrig bleiben)\n\nf <- pres_abs ~\n  slope_scaled +\n  topo_pos_scaled +\n  us_scaled +\n  forest_prop_scaled +\n  dist_road_only_scaled +\n  dist_sett_scaled \n\n# in diesem Befehl kommt der Random-Factor (das Reh) hinzu und es wird eine Formel\n# daraus gemacht\n\nf_dredge <- paste(c(f, \"+ (1 | id)\"), collapse = \" \") |> as.formula()\n\n# Das Modell mit dieser Formel ausführen\n\nm <- glmer(f_dredge, data = DF_mod_day, family = binomial, na.action = \"na.fail\")\n\n# Das Modell in die dredge-Funktion einfügen (siehe auch unbedingt ?dredge)\n\nall_m <- dredge(m)\n\n# Importance values der einzelnen Variablen (Gibt an, wie bedeutsam eine bestimmte\n# Variable ist, wenn man viele verschiedene Modelle vergleicht (multimodel inference))\n\nsw(all_m)\n##                      dist_road_only_scaled forest_prop_scaled us_scaled\n## Sum of weights:      1.00                  1.00               1.00     \n## N containing models:   32                    32                 32     \n##                      slope_scaled dist_sett_scaled topo_pos_scaled\n## Sum of weights:      0.99         0.46             0.30           \n## N containing models:   32           32               32\n\n# Schlussendlich wird ein Modelaverage durchgeführt (Schwellenwert für das delta-AIC = 2)\n\navgmodel <- model.avg(all_m, rank = \"AICc\", subset = delta < 2)\nsummary(avgmodel)\n## \n## Call:\n## model.avg(object = get.models(object = all_m, subset = delta < \n##     2), rank = \"AICc\")\n## \n## Component model call: \n## glmer(formula = pres_abs ~ <4 unique rhs>, data = DF_mod_day, family = \n##      binomial, na.action = na.fail)\n## \n## Component models: \n##        df   logLik    AICc delta weight\n## 1346    6 -2268.17 4548.37  0.00   0.38\n## 12346   7 -2267.34 4548.71  0.34   0.32\n## 13456   7 -2268.01 4550.04  1.68   0.16\n## 123456  8 -2267.16 4550.35  1.98   0.14\n## \n## Term codes: \n## dist_road_only_scaled      dist_sett_scaled    forest_prop_scaled \n##                     1                     2                     3 \n##          slope_scaled       topo_pos_scaled             us_scaled \n##                     4                     5                     6 \n## \n## Model-averaged coefficients:  \n## (full average) \n##                        Estimate Std. Error Adjusted SE z value Pr(>|z|)    \n## (Intercept)           -0.432191   0.139554    0.139597   3.096  0.00196 ** \n## dist_road_only_scaled  0.416554   0.046861    0.046875   8.886  < 2e-16 ***\n## forest_prop_scaled     0.818821   0.057266    0.057282  14.295  < 2e-16 ***\n## slope_scaled          -0.158651   0.049230    0.049245   3.222  0.00127 ** \n## us_scaled              0.390805   0.041070    0.041083   9.513  < 2e-16 ***\n## dist_sett_scaled      -0.036839   0.058045    0.058054   0.635  0.52571    \n## topo_pos_scaled        0.006678   0.022846    0.022852   0.292  0.77013    \n##  \n## (conditional average) \n##                       Estimate Std. Error Adjusted SE z value Pr(>|z|)    \n## (Intercept)           -0.43219    0.13955     0.13960   3.096  0.00196 ** \n## dist_road_only_scaled  0.41655    0.04686     0.04688   8.886  < 2e-16 ***\n## forest_prop_scaled     0.81882    0.05727     0.05728  14.295  < 2e-16 ***\n## slope_scaled          -0.15865    0.04923     0.04924   3.222  0.00127 ** \n## us_scaled              0.39081    0.04107     0.04108   9.513  < 2e-16 ***\n## dist_sett_scaled      -0.08030    0.06208     0.06210   1.293  0.19597    \n## topo_pos_scaled        0.02197    0.03717     0.03718   0.591  0.55451    \n## ---\n## Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n\n#| eval: false\n#| error: true\n#| echo: false\n\n# hier wird die Formel für die dredge-Funktion vorbereitet (die Variablen V1-V8\n# sind jene welche nach der univariaten Variablenselektion noch übrig bleiben)\n\nf <- pres_abs ~\n  slope_scaled +\n  topo_pos_scaled +\n  us_scaled +\n  os_scaled +\n  forest_prop_scaled +\n  dist_road_only_scaled +\n  dist_road_trails_scaled +\n  dist_sett_scaled \n\n# inn diesem Befehl kommt der Random-Factor (das Reh) hinzu und es wird eine Formel\n# daraus gemacht\n\nf_dredge <- paste(c(f, \"+ (1 | id)\"), collapse = \" \") |> as.formula()\n\n# Das Modell mit dieser Formel ausführen\n\nm <- glmer(f_dredge, data = DF_mod_day, family = binomial, na.action = \"na.fail\")\n\ncar::vif(m)\n##            slope_scaled         topo_pos_scaled               us_scaled \n##                1.514328                1.083853                1.242521 \n##               os_scaled      forest_prop_scaled   dist_road_only_scaled \n##                2.626511                2.664066                5.844383 \n## dist_road_trails_scaled        dist_sett_scaled \n##                5.674976                1.427576\nmean(car::vif(m))\n## [1] 2.759777\n```\n:::\n",
    "supporting": [
      "5_Variablenselektion_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}