{
  "hash": "ac66220f139db586c3827a85e0bb5862",
  "result": {
    "markdown": "---\ndate: 2023-11-14\nlesson: StatKons2\nthema: PCA\nindex: 1\nformat:\n  html:\n    code-tools:\n      source: true\n---\n\n\n# StatKons2: Demo\n\n- Download dieses Demoscript via \"\\</\\>Code\" (oben rechts)\n- Datensatz *dave_sveg.csv* von @wildi2017\n\n\n::: {.cell}\n\n:::\n\n\n## PCA mit sveg\n\n::: {.cell}\n\n```{.r .cell-code}\n# Mit Beispieldaten aus Wildi (2013, 2017)\nlibrary(\"labdsv\")\nlibrary(\"readr\")\n\nsveg <- read_delim(\"datasets/statKons/dave_sveg.csv\")\nhead(sveg)\nstr(sveg)\n# View(sveg)\n\n# PCA-----------\n# Deckungen Wurzeltransformiert, cor=T erzwingt Nutzung der Korrelationsmatrix\no.pca <- labdsv::pca(sveg^0.25, cor = T)\no.pca2 <- stats::prcomp(sveg^0.25)\n\n# Koordinaten im Ordinationsraum => Y\nhead(o.pca$scores)\nhead(o.pca2$x)\n\n# Korrelationen der Variablen mit den Ordinationsachsen\nhead(o.pca$loadings)\nhead(o.pca2$rotation)\n\n# Erklaerte Varianz der Achsen (sdev ist die Wurzel daraus)\n# früher gabs den Befehl summary()\n# jetzt von hand: standardabweichung im quadrat/totale varianz * 100 (um prozentwerte zu bekommen)\nE <- o.pca$sdev^2 / o.pca$totdev * 100\nE[1:5] # erste fünf PCA\n\n# package stats funktioniert summary()\nsummary(o.pca2)\n\n# PCA-Plot der Lage der Beobachtungen im Ordinationsraum\nplot(o.pca$scores[, 1], o.pca$scores[, 2], type = \"n\", asp = 1, xlab = \"PC1\", ylab = \"PC2\")\npoints(o.pca$scores[, 1], o.pca$scores[, 2], pch = 18)\n```\n\n::: {.cell-output-display}\n![](StatKons2_Demo_PCA_files/figure-html/unnamed-chunk-2-1.png){width=672}\n:::\n\n```{.r .cell-code}\n\nplot(o.pca$scores[, 1], o.pca$scores[, 3], type = \"n\", asp = 1, xlab = \"PC1\", ylab = \"PC3\")\npoints(o.pca$scores[, 1], o.pca$scores[, 3], pch = 18)\n```\n\n::: {.cell-output-display}\n![](StatKons2_Demo_PCA_files/figure-html/unnamed-chunk-2-2.png){width=672}\n:::\n\n```{.r .cell-code}\n\n# Subjektive Auswahl von Arten zur Darstellung\nsel.sp <- c(3, 11, 23, 39, 46, 72, 77, 96, 101, 119)\nsnames <- names(sveg[, sel.sp])\nsnames\n\n# PCA-Plot der Korrelationen der Variablen (hier Arten) mit den Achsen\n# (hier reduction der observationen)\nx <- o.pca$loadings[, 1]\ny <- o.pca$loadings[, 2]\nplot(x, y, type = \"n\", asp = 1)\narrows(0, 0, x[sel.sp], y[sel.sp], length = 0.08)\ntext(x[sel.sp], y[sel.sp], snames, pos = 1, cex = 0.6)\n```\n\n::: {.cell-output-display}\n![](StatKons2_Demo_PCA_files/figure-html/unnamed-chunk-2-3.png){width=672}\n:::\n\n```{.r .cell-code}\n\n# hier gehts noch zu weiteren Beispielen zu PCA's:\n# https://stats.stackexchange.com/questions/102882/steps-done-in-factor-analysis-compared-to-steps-done-in-pca/102999#102999\n# https://stats.stackexchange.com/questions/222/what-are-principal-component-scores\n```\n:::\n\n\n## PCA mit Beispiel aus Skript\n\n::: {.cell}\n\n```{.r .cell-code}\n# Idee von Ordinationen aus Wildi p. 73-74\n\n# Für Ordinationen benötigen wir Matrizen, nicht Data.frames\n# Generieren von Daten\nraw <- matrix(c(1, 2, 2.5, 2.5, 1, 0.5, 0, 1, 2, 4, 3, 1), nrow = 6)\ncolnames(raw) <- c(\"spec.1\", \"spec.2\")\nrownames(raw) <- c(\"r1\", \"r2\", \"r3\", \"r4\", \"r5\", \"r6\")\nraw\n\n# originale Daten im zweidimensionalen Raum\nx1 <- raw[, 1]\ny1 <- raw[, 2]\nz <- c(rep(1:6))\n\n# Plot Abhängigkeit der Arten vom Umweltgradienten\nplot(c(x1, y1) ~ c(z, z),\n  type = \"n\", axes = T, bty = \"l\", las = 1, xlim = c(1, 6), ylim = c(0, 5),\n  xlab = \"Umweltgradient\", ylab = \"Deckung der Arten\"\n)\npoints(x1 ~ z, pch = 21, type = \"b\")\npoints(y1 ~ z, pch = 16, type = \"b\")\n```\n\n::: {.cell-output-display}\n![](StatKons2_Demo_PCA_files/figure-html/unnamed-chunk-3-1.png){width=672}\n:::\n\n```{.r .cell-code}\n\n# zentrierte Daten\ncent <- scale(raw, scale = F)\nx2 <- cent[, 1]\ny2 <- cent[, 2]\n\n# rotierte Daten\no.pca <- pca(raw)\nx3 <- o.pca$scores[, 1]\ny3 <- o.pca$scores[, 2]\n\n# Visualisierung der Schritte im Ordinationsraum\nplot(c(y1, y2, y3) ~ c(x1, x2, x3),\n  type = \"n\", axes = T, bty = \"l\", las = 1, xlim = c(-4, 4),\n  ylim = c(-4, 4), xlab = \"Art 1\", ylab = \"Art 2\"\n)\npoints(y1 ~ x1, pch = 21, type = \"b\", col = \"green\", lwd = 2)\npoints(y2 ~ x2, pch = 16, type = \"b\", col = \"red\", lwd = 2)\npoints(y3 ~ x3, pch = 17, type = \"b\", col = \"blue\", lwd = 2)\n```\n\n::: {.cell-output-display}\n![](StatKons2_Demo_PCA_files/figure-html/unnamed-chunk-3-2.png){width=672}\n:::\n\n```{.r .cell-code}\n\n# zusammengefasst:-------\n\n# Durchführung der PCA\npca <- pca(raw)\n\n# Koordinaten im Ordinationsraum\npca$scores\n\n# Korrelationen der Variablen mit den Ordinationsachsen\npca$loadings\n\n# Erklärte Varianz der Achsen in Prozent\nE <- pca$sdev^2 / pca$totdev * 100\nE\n\n### excurs für weitere r-packages####\n\n# mit prcomp, ein weiteres Package für Ordinationen\npca.2 <- stats::prcomp(raw, scale = F)\nsummary(pca.2)\nplot(pca.2)\n```\n\n::: {.cell-output-display}\n![](StatKons2_Demo_PCA_files/figure-html/unnamed-chunk-3-3.png){width=672}\n:::\n\n```{.r .cell-code}\nbiplot(pca.2)\n```\n\n::: {.cell-output-display}\n![](StatKons2_Demo_PCA_files/figure-html/unnamed-chunk-3-4.png){width=672}\n:::\n\n```{.r .cell-code}\n\n# mit vegan, ein anderes Package für Ordinationen\npca.3 <- vegan::rda(raw, scale = FALSE) # Die Funktion rda führt ein PCA aus an wenn nicht Umwelt- und Artdaten definiert werden\n# scores(pca.3,display=c(\"sites\"))\n# scores(pca.3,display=c(\"species\"))\nsummary(pca.3, axes = 0)\nbiplot(pca.3, scaling = 2)\nbiplot(pca.3, scaling = \"species\") # scaling=species macht das selbe wie scaling=2\n```\n\n::: {.cell-output-display}\n![](StatKons2_Demo_PCA_files/figure-html/unnamed-chunk-3-5.png){width=672}\n:::\n:::\n\n\n## CA mit sveg\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(\"vegan\")\nlibrary(\"FactoMineR\") # siehe Beispiel hier: https://www.youtube.com/watch?v=vP4korRby0Q\n\n# ebenfalls mit transformierten daten\no.ca <- cca(sveg^0.5) # package vegan\no.ca1 <- CA(sveg^0.5) # package FactoMineR\n```\n\n::: {.cell-output-display}\n![](StatKons2_Demo_PCA_files/figure-html/unnamed-chunk-4-1.png){width=672}\n:::\n\n```{.r .cell-code}\n\n# Arten (o) und Communities (+) plotten\nplot(o.ca)\n```\n\n::: {.cell-output-display}\n![](StatKons2_Demo_PCA_files/figure-html/unnamed-chunk-4-2.png){width=672}\n:::\n\n```{.r .cell-code}\nsummary(o.ca1)\n\n# Nur Arten plotten\nx <- o.ca$CA$u[, 1]\ny <- o.ca$CA$u[, 2]\nplot(x, y)\n```\n\n::: {.cell-output-display}\n![](StatKons2_Demo_PCA_files/figure-html/unnamed-chunk-4-3.png){width=672}\n:::\n\n```{.r .cell-code}\n\n# Anteilige Varianz, die durch die ersten beiden Achsen erklaert wird\no.ca$CA$eig[1:63] / sum(o.ca$CA$eig)\n```\n:::\n\n\n## NMDS mit sveg\n\n::: {.cell}\n\n```{.r .cell-code}\n# NMDS----------\n\n# Distanzmatrix als Start erzeugen\nlibrary(\"MASS\")\n\nmde <- vegdist(sveg, method = \"euclidean\")\nmdm <- vegdist(sveg, method = \"manhattan\")\n\n# Zwei verschiedene NMDS-Methoden\nset.seed(1) # macht man, wenn man bei einer Wiederholung exakt die gleichen Ergebnisse will\no.imds <- isoMDS(mde, k = 2) # mit K = Dimensionen\nset.seed(1)\no.mmds <- metaMDS(mde, k = 3) # scheint nicht mit 2 Dimensionen zu konvergieren\n\nplot(o.imds$points)\nplot(o.mmds$points)\n\n# Stress =  Abweichung der zweidimensionalen NMDS-Loesung von der originalen Distanzmatrix\nstressplot(o.imds, mde)\nstressplot(o.mmds, mde)\n```\n:::\n\n\n## PCA mit mtcars\n\n::: {.cell}\n\n```{.r .cell-code}\n# Beispiel inspiriert von Luke Hayden: https://www.datacamp.com/community/tutorials/pca-analysis-r\n\n# Ausgangslage: viel zusammenhängende Variablen\n# Ziel: Reduktion der Variablenkomplexität\n# WICHTIG hier: Datenformat muss Wide sein! Damit die Matrixmultiplikation gemacht werden kann\n\n# lade Datei\ncars <- mtcars\n\n# Korrelationen\ncor <- cor(cars[, c(1:7, 10, 11)])\ncor[abs(cor) < .7] <- 0\ncor\n\n# definiere Datei für PCA\ncars <- mtcars[, c(1:7, 10, 11)]\n\n# pca\n# achtung unterschiedliche messeinheiten, wichtig es muss noch einheitlich transfomiert werden\nlibrary(\"FactoMineR\") # siehe Beispiel hier: https://www.youtube.com/watch?v=vP4korRby0Q\no.pca <- PCA(cars, scale.unit = TRUE) # entweder korrelations oder covarianzmatrix\n\n# schaue output an\nsummary(o.pca) # generiert auch automatische plots\n```\n:::\n\n\n## CA mit mtcars\n\n::: {.cell}\n\n```{.r .cell-code}\n# ebenfalls mit transformierten daten\no.ca <- vegan::cca(cars)\no.ca1 <- FactoMineR::CA(cars) # blau: auots, rot: variablen\n```\n\n::: {.cell-output-display}\n![](StatKons2_Demo_PCA_files/figure-html/unnamed-chunk-7-1.png){width=672}\n:::\n\n```{.r .cell-code}\n\n# plotten (schwarz: autos, rot: variablen)\nplot(o.ca)\n```\n\n::: {.cell-output-display}\n![](StatKons2_Demo_PCA_files/figure-html/unnamed-chunk-7-2.png){width=672}\n:::\n\n```{.r .cell-code}\nsummary(o.ca)\nsummary(o.ca1)\n\n# Nur autos plotten; wieso?\nx <- o.ca$CA$u[, 1]\ny <- o.ca$CA$u[, 2]\nplot(x, y)\n```\n\n::: {.cell-output-display}\n![](StatKons2_Demo_PCA_files/figure-html/unnamed-chunk-7-3.png){width=672}\n:::\n\n```{.r .cell-code}\n\n# Anteilige Varianz, die durch die ersten beiden Achsen erklaert wird\no.ca$CA$eig[1:8] / sum(o.ca$CA$eig)\n```\n:::\n\n\n## NMDS mit mtcars\n\n::: {.cell}\n\n```{.r .cell-code}\n# Distanzmatrix als Start erzeugen\n\nmde <- vegan::vegdist(cars, method = \"euclidean\")\nmdm <- vegan::vegdist(cars, method = \"manhattan\")\n\n# Zwei verschiedene NMDS-Methoden\nset.seed(1) # macht man, wenn man bei einer Wiederholung exakt die gleichen Ergebnisse will\no.mde.mass <- MASS::isoMDS(mde, k = 2) # mit K = Dimensionen\no.mdm.mass <- MASS::isoMDS(mdm)\n\nset.seed(1)\no.mde.vegan <- vegan::metaMDS(mde, k = 1) # scheint nicht mit 2 Dimensionen zu konvergieren\no.mdm.vegan <- vegan::metaMDS(mdm, k = 2)\n\n# plot euclidean distance\nplot(o.mde.mass$points)\n```\n\n::: {.cell-output-display}\n![](StatKons2_Demo_PCA_files/figure-html/unnamed-chunk-8-1.png){width=672}\n:::\n\n```{.r .cell-code}\nplot(o.mde.vegan$points)\n```\n\n::: {.cell-output-display}\n![](StatKons2_Demo_PCA_files/figure-html/unnamed-chunk-8-2.png){width=672}\n:::\n\n```{.r .cell-code}\n\n# plot manhattan distance\nplot(o.mdm.mass$points)\n```\n\n::: {.cell-output-display}\n![](StatKons2_Demo_PCA_files/figure-html/unnamed-chunk-8-3.png){width=672}\n:::\n\n```{.r .cell-code}\nplot(o.mdm.vegan$points)\n```\n\n::: {.cell-output-display}\n![](StatKons2_Demo_PCA_files/figure-html/unnamed-chunk-8-4.png){width=672}\n:::\n\n```{.r .cell-code}\n\n# Stress =  Abweichung der zweidimensionalen NMDS-Loesung von der originalen Distanzmatrix\nvegan::stressplot(o.mde.vegan, mde)\n```\n\n::: {.cell-output-display}\n![](StatKons2_Demo_PCA_files/figure-html/unnamed-chunk-8-5.png){width=672}\n:::\n\n```{.r .cell-code}\nvegan::stressplot(o.mde.mass, mde)\n```\n\n::: {.cell-output-display}\n![](StatKons2_Demo_PCA_files/figure-html/unnamed-chunk-8-6.png){width=672}\n:::\n:::\n",
    "supporting": [
      "StatKons2_Demo_PCA_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}